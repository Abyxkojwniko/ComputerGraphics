# Finishing up Viewing
##
![[Pasted image 20250714110645.png]]
定义一个近平面的宽高比：
那么我们的可视角度就是中间红线的角度，垂直的角度/2就是下方的三角形
![[Pasted image 20250714111745.png]]
MVP后所有的坐标都会转化到[-1,1]上，那么如何将其画到屏幕上
从屏幕上来说，屏幕就是一个光栅成像设备，就是确定哪些像素应该被绘制成为什么颜色
像素的坐标也被认定为(x,y)形式，比如蓝色像素就可以被认定为(2,1)，像素的中心应该是(x+0.5,y+0.5)，对于所有的像素都应该如此
![[Pasted image 20250714112557.png]]
那么那么中心应该就放在屏幕中心，那么就是屏幕空间，z轴不进行改变，转换方程就如下方的公式
![[Pasted image 20250715140334.png]]
![[Pasted image 20250714113019.png]]
通过公式变化，可以将其变为一个2D的图片了
### 为什么要选择三角形：
三角形是多边形的基础
内外部定义清楚，三角形中任何一个点对于其他点的位置关系是可以找出来的，可以轻松判断是否在三角形内
比如可以使用叉乘，这样就可以判断在边的左侧还是右侧，实际上在三角形中的点，每个点都应该在三角形的左侧，所以可以判断该点是否在这个三角形中
# Sampling a Function

采样实际上就是离散化的过程
```c++
for(int x=0;x<xmax;x+=0.2){
	output[x]=f(x);
}
```

可以判断三角形的中心是否在三角形内，这里可以优化，因为你可以根据三角形的三个坐标来进行判断
```c++
for(int x=0;x<xmax;x++){
	for(int y=0;y<ymax;y++){
		image[x][y]=inside(tri,x+0.5,y+0.5)
	}
}
```
如何判断是否在三角形内
我们使用叉乘来进行判断，因为在三角形中，我们可以知道在三角形内所有的点与边叉乘都应该为正，否则得到的值会有负值
# 反走样 

 走样：最常见的就是锯齿
 走样原因：采样速度根不上图像变化的速度，信号变化速度特别快
 Aliasing：
	 1.锯齿
	 2.摩尔纹
	 3.车轮效应
  如何进行采样进行得到比较好的采样：
  可以进行模糊化操作，然后用像素中心进行采样，采样前要做模糊 ，不能线采样后模糊 
  ![[Pasted image 20250718133740.png]]

但是为什么采样速度不够就会失真？
对于高频样本来说，低频采样会导致无法恢复出以往的样本曲线，并且不同的高频样本，也无法通过低频采样找出区别，如下图
![[Pasted image 20250721112838.png]]
并且一个采样方法采样两个不同信号，其采样完全相同，这就不对
![[Pasted image 20250721112932.png]]
#### 傅里叶变换的作用

将图形从时域变为频域
![[Pasted image 20250721113126.png]]
中心是低频频域，边缘是高维频域，用亮度表示信息的多少，横竖两条亮线是因为在实际处理中，图片会在左右上下反复重复，所以这里边缘界面变化特别大，所以变化会特别剧烈
#### 高通滤波后的结果
![[Pasted image 20250721113326.png]]
在图像内容的边界上变化非常剧烈，所以屏蔽低频后，高频信息会突出边界
#### 低通滤波
![[Pasted image 20250721113630.png]]
### 滤波=去掉一个特定的频率的信息
### 从另一个角度理解可以=Convolution=Averaging

#### Convolution
![[Pasted image 20250721114230.png]]
#### 卷积定理
![[Pasted image 20250721114548.png]]
实际上时域上的卷积等于频域上的乘积
![[Pasted image 20250721114733.png]]
#### 时域盒子变大了，为什么频域变小了
这是因为如果卷积用更大的box去卷积，那么图像实际是更加模糊，那么其实留下了更少的频域信息，那么频域就更小了
![[Pasted image 20250721152332.png]]
#### 那么频域上，采样意味着什么？
![[Pasted image 20250721152409.png]]
等于我们只留下某些位置上函数的值和点
那么时域上的乘积等于频域上的卷积，那么变换后如上图右列，实际上是将频域不断重复
那么采样率不足就会导致原始信号的复制粘贴后每个频谱的间隔非常小，就会出现频域混叠的现象

#### 如何减少这种问题：

1.直接增大采样频率：但是受限于硬件设备，不好做
2.如何反走样：先做模糊在做采样
   为什么有用：
	   模糊那么相当于进行了低通滤波，对于频谱来说如下图，这样一来就可以让频谱得到间隔小一些
	   ![[Pasted image 20250721153152.png]]
实际的操作中，使用什么滤波器进行卷积操作：
	用一个一定大小的低通滤波器进行卷积就可以了，最简单的块就是一个像素
	![[Pasted image 20250721153428.png]]
	那么每个像素的值如何确定：
	![[Pasted image 20250721153559.png]]
### MSAA Antialiasing By Supersamling

#### 如何工作：

- 像素再细分
- 然后判断每个像素中有百分之多少在被覆盖的区域中
- 采样隐含在这其中了，MSAA并非靠增加分辨率解决采样问题
- ![[Pasted image 20250721155247.png]]

## 那么通过MSAA 可以得到抗锯齿效果，但是，代价是什么呢？

增大了非常多的计算量， 但是实际打游戏的时候并不会下降4倍帧率，这是为什么？
因为并不是所有格子都会通过4* 4or 2* 2来进行采样点的，采样点会通过不同的像素复用
，可以用一个不规则的分布增加这些采样点

抗锯齿方法： 
	FXAA：通过后期处理，把锯齿去除掉，通过图像匹配的方法将边界进行匹配
	TAA：找上一帧的信息，复用上一帧感知到的结果，然后继续应用
	这两种方法得到了广泛的应用
#### Super resolution/super samping

![[Pasted image 20250721162126.png]]
#### 超分辨率：

实际如何在采样率不足的情况下，但是在拉大的时候但是不看到锯齿
DLSS：通过深度学习去猜测
## 1.画家算法
![[Pasted image 20250722145627.png]]
判断先后顺序之后再进行绘制
 ![[Pasted image 20250722142253.png]]
 这种互相遮挡的物体就不能解决，因为无法判断深度关系
## 2.Z-Buffer
![[Pasted image 20250722142407.png]]
只存储每个像素最浅的深度信息，颜色信息和深度信息同时生成
![[Pasted image 20250722142624.png]]
 简单来说流程，如右图，黑色代表更近，白色代表更远，当然左边渲染出来还有投影和亮度等问题，在实际存储的时候，也应该注意这些问题
 ![[Pasted image 20250722143047.png]]
 初始化所有的z距离为无限远
 然后对所有三角形中的点，记录其中的最浅深度，然后更新它的颜色
 ![[Pasted image 20250722143310.png]]
 那么复杂度也不太高，O(n)，这里我们并没有排序，只是做了比较
 ![[Pasted image 20250722144225.png]]
# Shading
### 我们现在学了什么
![[Pasted image 20250722151426.png]]
视图变换，左右变换，投影变换，简单的三角形判断，![[Pasted image 20250722151639.png]]
这个更真实也是因为着色更好，这是因为真实世界是非常复杂的，在不同关照和角度下颜色并非是一成不变的，以及每个像素的亮度也有不同的变化。
着色实际上是对不同物体应用不同材质的问题。因为不同材质对不同的光线有不同的方法。
![[Pasted image 20250722152159.png]]
第一个反射是镜面反射，这里几乎是全反射
第二个反射是漫反射部分
第三个反射是并不是直接光照，而是间接光照，通过其余部分反射的光再反射进入人眼
![[Pasted image 20250722153125.png]]
光照这里是一个点的光照，在一个像素点上，我们可以认为是一个平面，所以可以认定为法向量
v输入是相机方向也就是观测方向
n是该点的法线方向
l是光源方向，也就是光照方向
##### shadows并不等于shading，在渲染过程中不会有阴影出现，如下图
![[Pasted image 20250722154731.png]]

### Diffuse Reflection
#### Light is scattered uniformly in all directions
![[Pasted image 20250722154922.png]]
表面的朝向和光源有一定夹角，这种时候得到的明暗是不一样的，这是因为接受光的量是不同的，单位面积中接受的能量更小，那么计算光照能量就是计算光照方向和法相的角度 
我们认为在任何一个时刻点光源散发出的能量一定集中在一个球壳上，并且每个球壳的能量是完全相同的那么每个点的能量是I/R^2
![[Pasted image 20250722160403.png]]
那么diffuse的表示方法为：
![[Pasted image 20250722160648.png]]
接受的能量表示为到达的能量乘以接受的能量的比，这样就可以计算出物体的明暗，这里我们只考虑了反射没有考虑折射，右边的公式表示了得到的最终能量，左边的kd是指漫反射的系数，表示这个点是否吸收能量。
那么不管是从什么方向上看，那么这个图像应该是一模一样的，应该和v没有任何关系。
![[Pasted image 20250722161653.png]]
漫反射的kd决定了颜色有多么明亮，也就是亮度
#### 高光
![[Pasted image 20250723133302.png]]
光滑物体的反射方向接近镜面方向，我的观察方向和镜面反射方向相近的时候才能看到高光，也就是V和R足够接近的时候，才能看到高光。
![[Pasted image 20250723133414.png]]
这时候法线方向和半角方向，也就是半程向量很接近，那么n和h接近就说明了v和l接近。
为了衡量是否能看到高光，就可以用n和h是否接近来衡量，那么两个向量点乘，越接近就越靠近1，越远就越靠近0
这里ks一般认定为一个白色，后续就变为一个两者点乘，这里没有考虑能量的扩散。
半程方向非常好算，比反射方向好算很多
![[Pasted image 20250723133903.png]]
如果我们只用夹角余弦生成高光，这里对于距离的容忍度非常大，所以现在我们对其增加次方，减少对距离的容忍度
![[Pasted image 20250723134036.png]]
考虑不同的行，镜面反射系数增加，增加亮度，随着指数p增长，高光逐渐变小
### 部分反射
![[Pasted image 20250723134144.png]]
做一个假设，对于任何一个点接收到来自环境的光都是相同的，这个环境光是一个常数，和观测方向，法线方向没有任何关系
![[Pasted image 20250723134337.png]]
所有的光相加得到最后的图
着色模型是考虑的对于任何一个点考虑的是什么样，要从任何视角来看，那么对于任何一个点都要看这些
## Shading Frequencies
![[Pasted image 20250723134910.png]]
着色频率也就是说着色应用到哪些点上
Flat shading：左边的分块做效果很差，一个平面做一次shading，
Gouraud shading：中间对于每个平面的每个顶点算出自己的法线，然后对顶点着色，三角形内部使用插值的方法算出色彩
Phong shading：右边对每一个像素进行着色，对每个三角形求法线，然后对里面每个像素求法线，对每个像素进行着色
![[Pasted image 20250723135816.png]]
具体的区别要取决于具体的模型，每一行用的模型都是一样的，对于每个三角形来说，最后的效果还是要看最终的几何形体， 也就是一个模型的三角形是多少
### 如何计算法线
![[Pasted image 20250723141306.png]]
任何一个顶点会与无数三角形有关联，顶点法线就是相邻线的法线求加权平均，权值根据三角形的面的大小来进行计算。
如何定义逐像素的法线，所有的法线都是方向，所以要进行归一化，这里要使用重心坐标来进行定义。
### Graphics（Real-time Rendering） Pipeline 图形管线，实时渲染管线
#### 渲染流程
![[Pasted image 20250723141924.png]]
定义顶点
定义哪些顶点变为三角形
然后对顶点进行操作，也就是渲染和着色
![[Pasted image 20250811141908.png]]
![[Pasted image 20250811141920.png]]
![[Pasted image 20250811141930.png]]
着色最重要的就是顶点or像素如何着色，这套渲染管线是可以编程的，可以被定义
## Texture Mapping（纹理映射，三角形中如何填入一张图）

shader本质上是能在硬件上执行的语言，可以通过opengl来编写shader
shader对于每个像素执行一次，

![[Pasted image 20250811144429.png]]
两个点光源的渲染加起来，这就是球的着色，但是球上有自己的颜色和图案，这个的基本区别，我们希望在物体的不同位置定义不同的属性。
实际上，任何一个三维物体的表面都是二维的，也就是说我们可以将其变为一张图，然后再放上去
![[Pasted image 20250811144913.png]]
任何一个三角形的顶点在纹理上我们都能找到对应的点
![[Pasted image 20250811145319.png]]
# Interpolation Across Triangles：对于顶点的属性，如何对三角形内部进行平滑过渡
